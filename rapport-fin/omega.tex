\chapter{Prédiction des séquences neuronales} % (fold)
\label{cha:Prédire des séquences neuronales}

Comme vu précédemment, il n'y a pas de donnés biologiques associées à la
\textit{pirouette} du ver, hormis sur son utilité et son rôle dans la recherche
de nourriture chez \celeg{}\cite{Gray2005}. L'une des hypothèses serait que le
circuit de la marche avant et celui de la marche arrière seraient actifs
simultanément pour réaliser une \textit{pirouette}. En effet le câblage du
circuit neural permettrait la modulation de l'activité des motoneurones pour
réaliser une \textit{pirouette}. Malheureusement le câblage seul du circuit ne
permet pas d'en prédire le fonctionnement, il faudrait des données telles que
des données d'imagerie calcique\footnote{Technique d'observation des signaux
nerveux en reliant le changement de concentration d'ion $Ca^{2+}$ avec
l'activité des neurones.}, ou la possible présence et rôles de
neuromodulateurs\footnote{Les neuromodulateurs sont des molécules qui ne
propagent pas d'information, mais influencent le transfert et/ou la recapture
de certain neurotransmetteurs. Ils peuvent donc radicalement modifier la
manière dont l'information transite.} chez \celeg{}.

Étant donné qu'il est actuellement impossible d'accéder à ce type de donné, une
alternative serait d'utiliser des algorithmes d'apprentissage pour essayer de
prédire des séquences neurales inconnues, à partir d'un entrainement sur des
séquences connues.

\section{Filtre de Kalman} % (fold)
\label{sec:Filtre de Kalman}

Le filtre de Kalman est un algorithme d'estimation récursif. Pour mesurer
l'état courant, il se sert ainsi de l'état précédent. Ce type de filtre peut
être utilisé pour réaliser du filtrage, du lissage, ou de la prédiction.
L'usage qui nous intéresse ici est un usage prédictif du filtre. Étant donné
que les données nécessaires à la déduction des séquences neuronales du ver ne
sont pas disponibles pour le mouvement de \textit{pirouette}, nous souhaitons
utiliser un filtre de Kalman pour prédire des séquences neurales inconnues et
comprendre quels neurones pourraient être en activité lors de la
\textit{pirouette} du ver.

Un filtre de Kalman nécessite 2 matrices pour réaliser la prédiction, une
matrice dite générative, et une matrice de transition\cite{Rao1999}. Calculer
ces deux matrices est dépendant du problème que l'on souhaite résoudre. Dans
notre cas il est plus simple de générer ses matrices à partir d'algorithme
d'apprentissage. Rajesh P. N. Rao a developpé un algorithme d'apprentissage
pour calculer la matrice générative et la matrice de transition dans le but de
modéliser le cortex visuel\cite{Rao1999}. C'est cet algorithme d'apprentissage
que nous allons utiliser pour réaliser notre filtre de Kalman.

\begin{figure}[ht]
   \begin{center}
      \psfig{width=15cm,figure=pic/kalman_filter.eps}
   \end{center}
   \caption[Schema du filtre de kalman]{Schema du filtre de kalman utilisé par
   Rajesh P. N. Rao. Source Rao, R. P. (1999). \textit{An optimal estimation
   approach to visual perception and learning}. Vision research, 39(11),
   1963-89. \cite{Rao1999}}
   \label{fig:filtre_kalman}
\end{figure}

Dans son article\cite{Rao1999} Rajesh P. N. Rao montre que l'implémentation du
filtre de Kalman permet de prendre en compte une partie des états précédents
pour prédire l'état suivant en cas d'ambiguïté; ainsi qu'il est suffisamment
robuste pour "resynchroniser" ses prédictions en cas de présentation d'élément
inattendu.

Nous verrons dans la suite deux tests qui montrent ces deux capacités du filtre.

\subsection{Équation du filtre} % (fold)
\label{sub:Équation du filtre}

La figure~\ref{fig:filtre_kalman} page~\pageref{fig:filtre_kalman}, représente
le filtre de kalman utilisé par Rajesh P. N. Rao et décrit en détail dans son
article \cite{Rao1999}. Le filtre réalise ses prédictions en calculant

\[ I_{td} = U\bar{r} \]

avec $U$ la matrice générative, $\bar{r}$ vecteur représentant l'état interne
du filtre, et $I_{td}$ la prédiction. Le vecteur d'état interne $\bar{r}$ de
\textit{k-éléments} caractérisant l'entrée donnée au filtre. La taille de ce
vecteur joue sur la qualité de la prédiction réalisé par le filtre.

Le filtre corrige ensuite sont estimation de $\bar{r}$ à l'aide de la
différence entre l'entré suivante $I$, et l'état estimé précédent. Puis le
vecteur $r$ est passé dans son état suivant à l'aide de la matrice $V$ de
transition pour estimer l'état attendu suivant.\\

Dans son algorithme, les calculs de l'\textit{Inverse Covariance} $\Sigma^{-1}$
et de la \textit{Normalization} $N$ sont remplacés par des scalaires bien
choisis (voir annexes~\ref{cha:Valeur des variables pour l'apprentissage}
page~\pageref{cha:Valeur des variables pour l'apprentissage} pour les valeurs
choisies) pour réduire le temps de calcul nécessaire à la fois à
l'apprentissage et à la prédiction.

% subsection Équation du filtre (end)

\subsection{Apprentissage d'$U$ et $V$} % (fold)
\label{sub:Apprentissage de U et V}

Les matrices $U$ et $V$ sont initialisées aléatoirement en les contraignants
à être au moins orthonormal, l'état interne $r$ lui, est initialisé au vecteur
nul. L'apprentissage est défini par :

\begin{equation}
   \label{eqn:learning_U}
   \hat{U}(t) = \bar{U}(t) + \overbrace{\alpha[I(t) - \bar{U}(t)\hat{r}(t)]\hat{r}(t)^T}^\text{erreur d'apprentissage}
\end{equation}
\begin{equation}
   \label{eqn:learning_V}
   \hat{V}(t-1) = \bar{V}(t-1) + \underbrace{\beta[\hat{r}(t) - r'(t)]\hat{r}(t-1)^T}_\text{erreur d'apprentissage}
\end{equation}

avec $\bar{U}(t) = \hat{U}(t-1)$, $\bar{V}(t-1) = \hat{V}(t-2)$, $\alpha$ et
$\beta$ les coefficients d'apprentissages et $r'(t)$ définis ci-dessous :

\begin{equation}
   \label{eqn:def_r_prime}
   r'(t) =  \bar{V}(t-1)\hat{r}(t-1) + \bar{m}(t-1)
\end{equation}
\begin{equation}
   \label{eqn:def_r_hat}
   \hat{r}(t) = r'(t) + \frac{N_0}{\sigma^2}\bar{U}(t)^T(I(t)-\bar{U}(t)r'(t))
\end{equation}

avec $\frac{N_0}{\sigma^2}$ la normalisation qui sera remplacée par un scalaire lors
de l'apprentissage.

La boucle d'apprentissage est réalisée autant de fois que nécessaire pour que
les erreurs d'apprentissages deviennent non significatives.

% subsection Apprentissage de U et V (end)

% section Filtre de Kalman (end)

\section{Test du filtre} % (fold)
\label{sec:Test du filtre}

\subsection{Séquence simple} % (fold)
\label{sub:Sequence simple}

Cet exemple est tiré de l'article de Rajesh P. N. Rao. Il permet de vérifier si
le filtre prédit correctement une séquence avec une ambiguïté (voir
fig.~\ref{fig:sequence_simple} page~\pageref{fig:sequence_simple}).

\begin{figure}[ht]
   \begin{center}
      \resizebox{150mm}{!}{\includegraphics{pic/graph_sequence_3_5.eps}}
   \end{center}
   \caption[Prédiction de séquence simple]{Séquence simple avec une ambiguïté
   toutes les 2 étapes. Le filtre arrive à déterminer où il en est dans la
   séquence, pour répondre correctement l'étape suivante. Le premier graphe est
   la séquence fournie à prédire, le deuxième est la prédiction du filtre, le
   troisième est l'erreur normalisée entre l'entrée attendue et la prédiction.
   Source personnelle}
   \label{fig:sequence_simple}
\end{figure}

La séquence représente un pixel blanc sur fond noir ayant 3 états possibles.
Position basse, intermédiaire et haute. Lorsqu'il est au milieu, deux choix sont
possibles, soit aller en haut, soit aller en bas. On voit que le filtre arrive
toujours à choisir la bonne position. Ceci est dû à la matrice de transition
$V$ qui va déterminer deux valeurs différentes à l'état interne $r$ pour définir
cette position selon l'état précédent\cite{Rao1999}.

Le filtre a été ici entrainé en présentant une cinquantaine de fois la séquence :
bas, milieu, haut, milieu et l'état interne $r$ est un vecteur de 5 éléments.

% subsection Sequence simple (end)

\subsection{Test simple de robustesse} % (fold)
\label{sub:Test simple de robustesse}

Ici le filtre a été entrainé de la même manière que pour la
figure~\ref{fig:sequence_simple}, et possède un aussi un état interne $r$ de
taille 5; mais la séquence qu'on lui présente ne correspond pas à son
entrainement (fig~\ref{fig:sequence_simple_erreur}
page~\pageref{fig:sequence_simple_erreur}).

On voit ainsi qu'à l'étape 8 le filtre attendait une position basse, alors que
nous lui présentont une position intermédiaire. L'étape 9 est donc entièrement
fausse puisque le filtre prédit la succession basse. Mais le filtre corrige
rapidement ses prédictions en seulement 1 étape supplémentaire.

\begin{figure}[ht]
   \begin{center}
      \resizebox{150mm}{!}{\includegraphics{pic/graph_sequence_3_error_5.eps}}
   \end{center}
   \caption[Prédiction de séquence simple, avec erreur]{Séquence similaire à la
   figure~\ref{fig:sequence_simple}, mais avec une position inattendue.
   L'entrainement est le même que pour la figure~\ref{fig:sequence_simple}, et
   le filtre se remet à prédire assez rapidement correctement. Le premier graphe
   est la séquence fournie à prédire, le deuxième est la prédiction du filtre,
   le troisième est l'erreur normalisée entre l'entrée attendue et la
   prédiction. Source personnelle}
   \label{fig:sequence_simple_erreur}
\end{figure}

% subsection Séquence simple avec surprise (end)

% section Test du filtre (end)

\section{Prédiction sur le ver complet} % (fold)
\label{sec:Prédiction sur le ver complet}

Le filtre de Kalman va être utilisé pour prédire la taille des muscles lors
des mouvements du ver. En effet, l'activité neuronale du ver peut être liée
directement à son activité musculaire. En premier lieu il va falloir
s'assurer que le filtre arrive à prédire correctement les mouvements du ver en
apprentissage non supervisé (fonctionnement par défaut du filtre de Kalman), et
ensuite on tentera de le contraindre à nous donner l'état neuronal lié à
l'état des muscles.

\subsection{Mouvement normal avant du ver} % (fold)
\label{sub:Mouvement normal avant du ver}

Une première étape consiste donc à vérifier si le filtre arrive à correctement
prédire l'état des muscles du ver lors d'un mouvement simple. Le mouvement
choisi en l'occurrence est la marche avant obtenue par simulation avec le
modèle du ver.

\begin{figure}[ht]
   \begin{center}
      \resizebox{150mm}{!}{\includegraphics{pic/graph_ver_complet.eps}}
   \end{center}
   \caption[Prédiction de la taille des muscles lors du mouvement simulé
   avant du ver]{Prédiction de la taille des muscles lors du mouvement simulé
   avant du ver. Le premier graphe est la séquence fournie à prédire, le
   deuxième est la prédiction du filtre, le troisième est l'erreur normalisée
   entre l'entrée attendue et la prédiction. Source personnelle}
   \label{fig:sequence_ver_complet}
\end{figure}

Les données d'entrainement pour l'apprentissage correspondent à l'évolution de
la longueur des 98 muscles du ver simulé pour une durée de 30 secondes de
simulation. Ce jeu d'entrainement est présenté entre 3000 et 5000 lors de la
phase d'apprentissage. L'état interne $r$ est ici un vecteur de 12 éléments.
Cette taille de vecteurs a été choisis car elle correspond au nombre d'unités
neuronales du ver.

Le même jeu de donnée que celui d'entrainement est ensuite fourni pour la phase
de prédiction. Sur la figure~\ref{fig:sequence_ver_complet} on peut voir que l'erreur
est grossièrement comprise entre $1\%$ et $7\%$ avec quelques rares endroits où l'erreur
excède $15\%$. Ce que nous considérons comme correct.

% subsection Mouvement normal avant du ver (end)

\subsection{Mouvement complexe} % (fold)
\label{sub:Mouvement complexe}

% subsection Mouvement complexe (end)

% section Ver complet (end)

% chapter Prédire les séquences neuronales (end)
